"""
Anti-Fraud Engine for FPO Economics Management System
Implements real-time transaction monitoring, anomaly detection, and fraud risk scoring.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import json
import statistics
import math
from decimal import Decimal

logger = logging.getLogger(__name__)


class AlertType(Enum):
    THRESHOLD_EXCEEDED = "THRESHOLD_EXCEEDED"
    PATTERN_ANOMALY = "PATTERN_ANOMALY"
    VELOCITY_CHECK = "VELOCITY_CHECK"
    SUSPICIOUS_BEHAVIOR = "SUSPICIOUS_BEHAVIOR"


class AlertStatus(Enum):
    OPEN = "OPEN"
    INVESTIGATING = "INVESTIGATING"
    RESOLVED = "RESOLVED"
    FALSE_POSITIVE = "FALSE_POSITIVE"


@dataclass
class FraudRiskScore:
    """Represents the fraud risk assessment for a transaction."""
    score: float  # 0-100 scale
    risk_level: str  # LOW, MEDIUM, HIGH, CRITICAL
    factors: List[str]  # Contributing risk factors
    recommendations: List[str]  # Suggested actions


@dataclass
class TransactionPattern:
    """Represents transaction patterns for anomaly detection."""
    member_id: str
    avg_amount: float
    std_deviation: float
    frequency_per_day: float
    typical_hours: List[int]
    common_transaction_types: List[str]


@dataclass
class FraudAlert:
    """Represents a fraud alert generated by the system."""
    alert_id: str
    transaction_id: str
    member_id: str
    risk_score: float
    alert_type: AlertType
    description: str
    timestamp: datetime
    status: AlertStatus
    metadata: Dict[str, Any]


class TransactionAnalyzer:
    """Analyzes transactions for fraud detection and pattern recognition."""
    
    def __init__(self, db_connection):
        self.db_connection = db_connection
        self.thresholds = self._load_default_thresholds()
        
    def _load_default_thresholds(self) -> Dict[str, float]:
        """Load default fraud detection thresholds."""
        return {
            'max_single_transaction': 100000.0,  # Maximum single transaction amount
            'max_daily_amount': 500000.0,        # Maximum daily transaction amount per member
            'max_transactions_per_hour': 10,     # Maximum transactions per hour
            'velocity_threshold': 5.0,           # Transaction velocity multiplier
            'amount_deviation_threshold': 3.0,   # Standard deviations from normal
            'suspicious_hour_start': 22,         # Start of suspicious hours (10 PM)
            'suspicious_hour_end': 6,            # End of suspicious hours (6 AM)
        }
    
    def analyze_transaction(self, transaction: Dict[str, Any]) -> FraudRiskScore:
        """
        Analyze a single transaction for fraud risk.
        
        Args:
            transaction: Transaction data containing id, member_id, amount, type, timestamp
            
        Returns:
            FraudRiskScore: Risk assessment with score and recommendations
        """
        risk_factors = []
        risk_score = 0.0
        recommendations = []
        
        # Amount-based analysis
        amount_risk, amount_factors = self._analyze_amount_risk(transaction)
        risk_score += amount_risk
        risk_factors.extend(amount_factors)
        
        # Velocity analysis
        velocity_risk, velocity_factors = self._analyze_velocity_risk(transaction)
        risk_score += velocity_risk
        risk_factors.extend(velocity_factors)
        
        # Pattern analysis
        pattern_risk, pattern_factors = self._analyze_pattern_anomaly(transaction)
        risk_score += pattern_risk
        risk_factors.extend(pattern_factors)
        
        # Time-based analysis
        time_risk, time_factors = self._analyze_time_risk(transaction)
        risk_score += time_risk
        risk_factors.extend(time_factors)
        
        # Determine risk level and recommendations
        risk_level = self._calculate_risk_level(risk_score)
        recommendations = self._generate_recommendations(risk_level, risk_factors)
        
        return FraudRiskScore(
            score=min(risk_score, 100.0),
            risk_level=risk_level,
            factors=risk_factors,
            recommendations=recommendations
        )
    
    def _analyze_amount_risk(self, transaction: Dict[str, Any]) -> Tuple[float, List[str]]:
        """Analyze transaction amount for risk factors."""
        amount = float(transaction['amount'])
        risk_score = 0.0
        factors = []
        
        # Check absolute thresholds
        if amount > self.thresholds['max_single_transaction']:
            risk_score += 40.0
            factors.append(f"Amount exceeds maximum threshold ({self.thresholds['max_single_transaction']})")
        
        # Check against member's historical patterns
        member_pattern = self._get_member_pattern(transaction['member_id'])
        if member_pattern:
            deviation = abs(amount - member_pattern.avg_amount) / member_pattern.std_deviation
            if deviation > self.thresholds['amount_deviation_threshold']:
                risk_score += 25.0
                factors.append(f"Amount deviates significantly from member's pattern ({deviation:.1f} std devs)")
        
        return risk_score, factors
    
    def _analyze_velocity_risk(self, transaction: Dict[str, Any]) -> Tuple[float, List[str]]:
        """Analyze transaction velocity for risk factors."""
        member_id = transaction['member_id']
        current_time = datetime.fromisoformat(transaction['timestamp'].replace('Z', '+00:00'))
        risk_score = 0.0
        factors = []
        
        # Check hourly transaction count
        hourly_count = self._get_hourly_transaction_count(member_id, current_time)
        if hourly_count > self.thresholds['max_transactions_per_hour']:
            risk_score += 30.0
            factors.append(f"High transaction frequency ({hourly_count} transactions in past hour)")
        
        # Check daily amount
        daily_amount = self._get_daily_transaction_amount(member_id, current_time)
        if daily_amount > self.thresholds['max_daily_amount']:
            risk_score += 35.0
            factors.append(f"Daily transaction limit exceeded ({daily_amount})")
        
        return risk_score, factors
    
    def _analyze_pattern_anomaly(self, transaction: Dict[str, Any]) -> Tuple[float, List[str]]:
        """Analyze transaction for pattern anomalies."""
        member_id = transaction['member_id']
        transaction_type = transaction['transaction_type']
        risk_score = 0.0
        factors = []
        
        member_pattern = self._get_member_pattern(member_id)
        if member_pattern:
            # Check if transaction type is unusual for this member
            if transaction_type not in member_pattern.common_transaction_types:
                risk_score += 15.0
                factors.append(f"Unusual transaction type for member: {transaction_type}")
        
        return risk_score, factors
    
    def _analyze_time_risk(self, transaction: Dict[str, Any]) -> Tuple[float, List[str]]:
        """Analyze transaction timing for risk factors."""
        timestamp = datetime.fromisoformat(transaction['timestamp'].replace('Z', '+00:00'))
        hour = timestamp.hour
        risk_score = 0.0
        factors = []
        
        # Check for suspicious hours (late night/early morning)
        if (hour >= self.thresholds['suspicious_hour_start'] or 
            hour <= self.thresholds['suspicious_hour_end']):
            risk_score += 10.0
            factors.append(f"Transaction during suspicious hours ({hour}:00)")
        
        return risk_score, factors
    
    def _get_member_pattern(self, member_id: str) -> Optional[TransactionPattern]:
        """Get historical transaction pattern for a member."""
        try:
            with self.db_connection.cursor() as cursor:
                # Get last 30 days of transactions
                cursor.execute("""
                    SELECT amount, transaction_type, timestamp
                    FROM transactions 
                    WHERE member_id = %s 
                    AND timestamp >= %s
                    ORDER BY timestamp DESC
                """, (member_id, datetime.now() - timedelta(days=30)))
                
                transactions = cursor.fetchall()
                if len(transactions) < 5:  # Need minimum data for pattern analysis
                    return None
                
                amounts = [float(t['amount']) for t in transactions]
                types = [t['transaction_type'] for t in transactions]
                hours = [t['timestamp'].hour for t in transactions]
                
                return TransactionPattern(
                    member_id=member_id,
                    avg_amount=statistics.mean(amounts),
                    std_deviation=statistics.stdev(amounts) if len(amounts) > 1 else 0.0,
                    frequency_per_day=len(transactions) / 30.0,
                    typical_hours=list(set(hours)),
                    common_transaction_types=list(set(types))
                )
        except Exception as e:
            logger.error(f"Error getting member pattern for {member_id}: {e}")
            return None
    
    def _get_hourly_transaction_count(self, member_id: str, current_time: datetime) -> int:
        """Get transaction count for the past hour."""
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    SELECT COUNT(*) as count
                    FROM transactions 
                    WHERE member_id = %s 
                    AND timestamp >= %s
                """, (member_id, current_time - timedelta(hours=1)))
                
                result = cursor.fetchone()
                return result['count'] if result else 0
        except Exception as e:
            logger.error(f"Error getting hourly transaction count: {e}")
            return 0
    
    def _get_daily_transaction_amount(self, member_id: str, current_time: datetime) -> float:
        """Get total transaction amount for the current day."""
        try:
            start_of_day = current_time.replace(hour=0, minute=0, second=0, microsecond=0)
            
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    SELECT COALESCE(SUM(amount), 0) as total
                    FROM transactions 
                    WHERE member_id = %s 
                    AND timestamp >= %s
                    AND transaction_type IN ('WITHDRAWAL', 'TRANSFER')
                """, (member_id, start_of_day))
                
                result = cursor.fetchone()
                return float(result['total']) if result else 0.0
        except Exception as e:
            logger.error(f"Error getting daily transaction amount: {e}")
            return 0.0
    
    def _calculate_risk_level(self, risk_score: float) -> str:
        """Calculate risk level based on score."""
        if risk_score >= 80:
            return "CRITICAL"
        elif risk_score >= 60:
            return "HIGH"
        elif risk_score >= 30:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_recommendations(self, risk_level: str, factors: List[str]) -> List[str]:
        """Generate recommendations based on risk level and factors."""
        recommendations = []
        
        if risk_level == "CRITICAL":
            recommendations.extend([
                "Immediately suspend transaction pending investigation",
                "Notify security team and member",
                "Require additional authentication for future transactions"
            ])
        elif risk_level == "HIGH":
            recommendations.extend([
                "Hold transaction for manual review",
                "Contact member to verify transaction",
                "Monitor member activity closely"
            ])
        elif risk_level == "MEDIUM":
            recommendations.extend([
                "Flag for enhanced monitoring",
                "Consider additional verification steps"
            ])
        else:
            recommendations.append("Continue normal processing")
        
        return recommendations


class AnomalyDetector:
    """Detects anomalies in member behavior and transaction patterns."""
    
    def __init__(self, db_connection):
        self.db_connection = db_connection
    
    def detect_member_anomalies(self, member_id: str, lookback_days: int = 30) -> List[Dict[str, Any]]:
        """
        Detect anomalies in a member's recent behavior.
        
        Args:
            member_id: Member to analyze
            lookback_days: Number of days to analyze
            
        Returns:
            List of detected anomalies
        """
        anomalies = []
        
        # Get member's transaction history
        transactions = self._get_member_transactions(member_id, lookback_days)
        if len(transactions) < 10:  # Need sufficient data
            return anomalies
        
        # Detect amount anomalies
        amount_anomalies = self._detect_amount_anomalies(transactions)
        anomalies.extend(amount_anomalies)
        
        # Detect frequency anomalies
        frequency_anomalies = self._detect_frequency_anomalies(transactions)
        anomalies.extend(frequency_anomalies)
        
        # Detect timing anomalies
        timing_anomalies = self._detect_timing_anomalies(transactions)
        anomalies.extend(timing_anomalies)
        
        return anomalies
    
    def _get_member_transactions(self, member_id: str, days: int) -> List[Dict[str, Any]]:
        """Get member's transactions for the specified period."""
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    SELECT transaction_id, amount, transaction_type, timestamp, metadata
                    FROM transactions 
                    WHERE member_id = %s 
                    AND timestamp >= %s
                    ORDER BY timestamp DESC
                """, (member_id, datetime.now() - timedelta(days=days)))
                
                return cursor.fetchall()
        except Exception as e:
            logger.error(f"Error getting member transactions: {e}")
            return []
    
    def _detect_amount_anomalies(self, transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Detect anomalies in transaction amounts using statistical methods."""
        amounts = [float(t['amount']) for t in transactions]
        anomalies = []
        
        if len(amounts) < 5:
            return anomalies
        
        mean_amount = statistics.mean(amounts)
        std_dev = statistics.stdev(amounts)
        
        # Use z-score to detect outliers
        for transaction in transactions:
            amount = float(transaction['amount'])
            z_score = abs(amount - mean_amount) / std_dev if std_dev > 0 else 0
            
            if z_score > 3.0:  # More than 3 standard deviations
                anomalies.append({
                    'type': 'amount_outlier',
                    'transaction_id': transaction['transaction_id'],
                    'description': f'Amount {amount} is {z_score:.1f} standard deviations from normal',
                    'severity': 'high' if z_score > 4.0 else 'medium',
                    'timestamp': transaction['timestamp']
                })
        
        return anomalies
    
    def _detect_frequency_anomalies(self, transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Detect anomalies in transaction frequency."""
        anomalies = []
        
        # Group transactions by day
        daily_counts = {}
        for transaction in transactions:
            date = transaction['timestamp'].date()
            daily_counts[date] = daily_counts.get(date, 0) + 1
        
        if len(daily_counts) < 7:  # Need at least a week of data
            return anomalies
        
        counts = list(daily_counts.values())
        mean_count = statistics.mean(counts)
        std_dev = statistics.stdev(counts) if len(counts) > 1 else 0
        
        # Check for days with unusually high activity
        for date, count in daily_counts.items():
            if std_dev > 0:
                z_score = (count - mean_count) / std_dev
                if z_score > 2.5:  # Significantly above normal
                    anomalies.append({
                        'type': 'frequency_spike',
                        'date': date.isoformat(),
                        'description': f'Unusually high activity: {count} transactions (normal: {mean_count:.1f})',
                        'severity': 'high' if z_score > 3.5 else 'medium',
                        'transaction_count': count
                    })
        
        return anomalies
    
    def _detect_timing_anomalies(self, transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Detect anomalies in transaction timing patterns."""
        anomalies = []
        
        # Analyze hour distribution
        hour_counts = {}
        for transaction in transactions:
            hour = transaction['timestamp'].hour
            hour_counts[hour] = hour_counts.get(hour, 0) + 1
        
        # Check for unusual late-night activity
        night_hours = [22, 23, 0, 1, 2, 3, 4, 5]
        night_transactions = sum(hour_counts.get(hour, 0) for hour in night_hours)
        total_transactions = len(transactions)
        
        if total_transactions > 0:
            night_percentage = (night_transactions / total_transactions) * 100
            if night_percentage > 20:  # More than 20% at night is suspicious
                anomalies.append({
                    'type': 'unusual_timing',
                    'description': f'High percentage of night transactions: {night_percentage:.1f}%',
                    'severity': 'medium',
                    'night_transaction_count': night_transactions,
                    'total_transactions': total_transactions
                })
        
        return anomalies


class FraudRuleEngine:
    """Manages configurable fraud detection rules and thresholds."""
    
    def __init__(self, db_connection):
        self.db_connection = db_connection
        self.rules = self._load_fraud_rules()
    
    def _load_fraud_rules(self) -> Dict[str, Any]:
        """Load fraud detection rules from database or configuration."""
        # Default rules - in production, these would be loaded from database
        return {
            'amount_rules': {
                'max_single_withdrawal': 100000.0,
                'max_daily_withdrawal': 500000.0,
                'max_transfer_amount': 250000.0
            },
            'velocity_rules': {
                'max_transactions_per_hour': 10,
                'max_transactions_per_day': 50,
                'min_time_between_large_transactions': 300  # seconds
            },
            'pattern_rules': {
                'suspicious_transaction_types': ['WITHDRAWAL', 'TRANSFER'],
                'require_verification_above': 50000.0,
                'block_night_transactions_above': 25000.0
            },
            'member_rules': {
                'new_member_transaction_limit': 10000.0,
                'suspended_member_block': True,
                'inactive_member_limit': 5000.0
            }
        }
    
    def evaluate_rules(self, transaction: Dict[str, Any], member_data: Dict[str, Any]) -> List[str]:
        """
        Evaluate all fraud rules against a transaction.
        
        Args:
            transaction: Transaction data
            member_data: Member information
            
        Returns:
            List of rule violations
        """
        violations = []
        
        # Check amount rules
        violations.extend(self._check_amount_rules(transaction))
        
        # Check velocity rules
        violations.extend(self._check_velocity_rules(transaction))
        
        # Check pattern rules
        violations.extend(self._check_pattern_rules(transaction))
        
        # Check member-specific rules
        violations.extend(self._check_member_rules(transaction, member_data))
        
        return violations
    
    def _check_amount_rules(self, transaction: Dict[str, Any]) -> List[str]:
        """Check amount-based rules."""
        violations = []
        amount = float(transaction['amount'])
        tx_type = transaction['transaction_type']
        
        if tx_type == 'WITHDRAWAL' and amount > self.rules['amount_rules']['max_single_withdrawal']:
            violations.append(f"Single withdrawal exceeds limit: {amount}")
        
        if tx_type == 'TRANSFER' and amount > self.rules['amount_rules']['max_transfer_amount']:
            violations.append(f"Transfer amount exceeds limit: {amount}")
        
        return violations
    
    def _check_velocity_rules(self, transaction: Dict[str, Any]) -> List[str]:
        """Check velocity-based rules."""
        violations = []
        # Implementation would check transaction frequency against rules
        # This is a simplified version
        return violations
    
    def _check_pattern_rules(self, transaction: Dict[str, Any]) -> List[str]:
        """Check pattern-based rules."""
        violations = []
        amount = float(transaction['amount'])
        tx_type = transaction['transaction_type']
        timestamp = datetime.fromisoformat(transaction['timestamp'].replace('Z', '+00:00'))
        
        # Check night transaction limits
        if (timestamp.hour >= 22 or timestamp.hour <= 6) and amount > self.rules['pattern_rules']['block_night_transactions_above']:
            violations.append(f"Large night transaction blocked: {amount} at {timestamp.hour}:00")
        
        return violations
    
    def _check_member_rules(self, transaction: Dict[str, Any], member_data: Dict[str, Any]) -> List[str]:
        """Check member-specific rules."""
        violations = []
        amount = float(transaction['amount'])
        member_status = member_data.get('status', 'ACTIVE')
        
        # Check suspended members
        if member_status == 'SUSPENDED' and self.rules['member_rules']['suspended_member_block']:
            violations.append("Transaction blocked: Member is suspended")
        
        # Check inactive member limits
        if member_status == 'INACTIVE' and amount > self.rules['member_rules']['inactive_member_limit']:
            violations.append(f"Transaction exceeds inactive member limit: {amount}")
        
        return violations
    
    def update_rule(self, rule_category: str, rule_name: str, value: Any) -> bool:
        """Update a specific fraud detection rule."""
        try:
            if rule_category in self.rules and rule_name in self.rules[rule_category]:
                self.rules[rule_category][rule_name] = value
                # In production, this would also update the database
                logger.info(f"Updated rule {rule_category}.{rule_name} to {value}")
                return True
            return False
        except Exception as e:
            logger.error(f"Error updating rule: {e}")
            return False